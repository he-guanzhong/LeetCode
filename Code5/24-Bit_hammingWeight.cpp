#include "head.h"
/* LCR 133. 位 1 的个数
编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为
'1' 的个数（也被称为 汉明重量).）。
提示：
    请注意，在某些语言（如
Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
    在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例
3 中，输入表示有符号整数 -3。
示例 1：
输入：n = 11 (控制台输入 00000000000000000000000000001011)
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：
输入：n = 128 (控制台输入 00000000000000000000000010000000)
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：
输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n
= -3） 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有
31 位为 '1'。
提示：
    输入必须是长度为 32 的 二进制串 。*/
int hammingWeight(uint32_t n) {
  int ans = 0;
  while (n) {
    n &= n - 1;
    ans++;
  }
  return ans;
}

// 方法一，按位与。n&1表示将n转化为二进制数，其末位是否为1。例如11&1=1，10&1=0。比较末位后，利用右移>>操作，将旧末尾剔除。
// 时间复杂度O(log2N)，n为10进制数，log2N为其二进制下的位数。
int hammingWeight1(uint32_t n) {
  int cnt = 0;
  while (n) {
    cnt += n & 1;
    n >>= 1;
  }
  return cnt;
}

// 方法二，利用n&n-1。其直接找到最右的1，并消除。例如100和011，按位与为000。注意不必加括号，因为符号优先级。四则运算>按位左右移>比较>按位与>各类赋值。
// 时间复杂度O(M)，M表示数字n二进制下1的位数
int hammingWeight2(uint32_t n) {
  int cnt = 0;
  while (n) {
    n &= n - 1;
    cnt++;
  }
  return cnt;
}
int main() {
  cout << hammingWeight(11) << " " << hammingWeight(128) << " "
       << hammingWeight(4294967293) << endl;
  cout << hammingWeight1(11) << " " << hammingWeight1(128) << " "
       << hammingWeight1(4294967293) << endl;

  return 0;
}